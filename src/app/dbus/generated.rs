// This code was autogenerated with `dbus-codegen-rust --crossroads -d org.mpris.MediaPlayer2.Lollypop -p /org/mpris/MediaPlayer2`, see https://github.com/diwic/dbus-rs
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub trait OrgMprisMediaPlayer2 {
    fn raise(&mut self) -> Result<(), dbus::MethodErr>;
    fn quit(&mut self) -> Result<(), dbus::MethodErr>;
    fn can_quit(&self) -> Result<bool, dbus::MethodErr>;
    fn fullscreen(&self) -> Result<bool, dbus::MethodErr>;
    fn set_fullscreen(&self, value: bool) -> Result<(), dbus::MethodErr>;
    fn can_raise(&self) -> Result<bool, dbus::MethodErr>;
    fn has_track_list(&self) -> Result<bool, dbus::MethodErr>;
    fn identity(&self) -> Result<String, dbus::MethodErr>;
    fn desktop_entry(&self) -> Result<String, dbus::MethodErr>;
    fn supported_uri_schemes(&self) -> Result<Vec<String>, dbus::MethodErr>;
    fn supported_mime_types(&self) -> Result<Vec<String>, dbus::MethodErr>;
}

pub fn register_org_mpris_media_player2<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgMprisMediaPlayer2 + Send + 'static,
{
    cr.register("org.mpris.MediaPlayer2", |b| {
        b.method("Raise", (), (), |_, t: &mut T, ()| t.raise());
        b.method("Quit", (), (), |_, t: &mut T, ()| t.quit());
        b.property::<bool, _>("CanQuit").get(|_, t| t.can_quit());
        b.property::<bool, _>("Fullscreen")
            .get(|_, t| t.fullscreen())
            .set(|_, t, value| t.set_fullscreen(value).map(|_| None));
        b.property::<bool, _>("CanRaise").get(|_, t| t.can_raise());
        b.property::<bool, _>("HasTrackList")
            .get(|_, t| t.has_track_list());
        b.property::<String, _>("Identity").get(|_, t| t.identity());
        b.property::<String, _>("DesktopEntry")
            .get(|_, t| t.desktop_entry());
        b.property::<Vec<String>, _>("SupportedUriSchemes")
            .get(|_, t| t.supported_uri_schemes());
        b.property::<Vec<String>, _>("SupportedMimeTypes")
            .get(|_, t| t.supported_mime_types());
    })
}

pub trait OrgMprisMediaPlayer2Player {
    fn next(&mut self) -> Result<(), dbus::MethodErr>;
    fn previous(&mut self) -> Result<(), dbus::MethodErr>;
    fn pause(&mut self) -> Result<(), dbus::MethodErr>;
    fn play_pause(&mut self) -> Result<(), dbus::MethodErr>;
    fn stop(&mut self) -> Result<(), dbus::MethodErr>;
    fn play(&mut self) -> Result<(), dbus::MethodErr>;
    fn seek(&mut self, offset: i64) -> Result<(), dbus::MethodErr>;
    fn set_position(
        &mut self,
        track_id: dbus::Path<'static>,
        position: i64,
    ) -> Result<(), dbus::MethodErr>;
    fn open_uri(&mut self, uri: String) -> Result<(), dbus::MethodErr>;
    fn playback_status(&self) -> Result<String, dbus::MethodErr>;
    fn loop_status(&self) -> Result<String, dbus::MethodErr>;
    fn set_loop_status(&self, value: String) -> Result<(), dbus::MethodErr>;
    fn rate(&self) -> Result<f64, dbus::MethodErr>;
    fn set_rate(&self, value: f64) -> Result<(), dbus::MethodErr>;
    fn shuffle(&self) -> Result<bool, dbus::MethodErr>;
    fn set_shuffle(&self, value: bool) -> Result<(), dbus::MethodErr>;
    fn metadata(&self) -> Result<arg::PropMap, dbus::MethodErr>;
    fn volume(&self) -> Result<f64, dbus::MethodErr>;
    fn set_volume(&self, value: f64) -> Result<(), dbus::MethodErr>;
    fn position(&self) -> Result<i64, dbus::MethodErr>;
    fn minimum_rate(&self) -> Result<f64, dbus::MethodErr>;
    fn maximum_rate(&self) -> Result<f64, dbus::MethodErr>;
    fn can_go_next(&self) -> Result<bool, dbus::MethodErr>;
    fn can_go_previous(&self) -> Result<bool, dbus::MethodErr>;
    fn can_play(&self) -> Result<bool, dbus::MethodErr>;
    fn can_pause(&self) -> Result<bool, dbus::MethodErr>;
    fn can_seek(&self) -> Result<bool, dbus::MethodErr>;
    fn can_control(&self) -> Result<bool, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgMprisMediaPlayer2PlayerSeeked {
    pub position: i64,
}

impl arg::AppendAll for OrgMprisMediaPlayer2PlayerSeeked {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.position, i);
    }
}

impl arg::ReadAll for OrgMprisMediaPlayer2PlayerSeeked {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgMprisMediaPlayer2PlayerSeeked {
            position: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgMprisMediaPlayer2PlayerSeeked {
    const NAME: &'static str = "Seeked";
    const INTERFACE: &'static str = "org.mpris.MediaPlayer2.Player";
}

pub fn register_org_mpris_media_player2_player<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgMprisMediaPlayer2Player + Send + 'static,
{
    cr.register("org.mpris.MediaPlayer2.Player", |b| {
        b.signal::<(i64,), _>("Seeked", ("Position",));
        b.method("Next", (), (), |_, t: &mut T, ()| t.next());
        b.method("Previous", (), (), |_, t: &mut T, ()| t.previous());
        b.method("Pause", (), (), |_, t: &mut T, ()| t.pause());
        b.method("PlayPause", (), (), |_, t: &mut T, ()| t.play_pause());
        b.method("Stop", (), (), |_, t: &mut T, ()| t.stop());
        b.method("Play", (), (), |_, t: &mut T, ()| t.play());
        b.method("Seek", ("Offset",), (), |_, t: &mut T, (offset,)| {
            t.seek(offset)
        });
        b.method(
            "SetPosition",
            ("TrackId", "Position"),
            (),
            |_, t: &mut T, (track_id, position)| t.set_position(track_id, position),
        );
        b.method("OpenUri", ("Uri",), (), |_, t: &mut T, (uri,)| {
            t.open_uri(uri)
        });
        b.property::<String, _>("PlaybackStatus")
            .get(|_, t| t.playback_status());
        b.property::<String, _>("LoopStatus")
            .get(|_, t| t.loop_status())
            .set(|_, t, value| t.set_loop_status(value).map(|_| None));
        b.property::<f64, _>("Rate")
            .get(|_, t| t.rate())
            .set(|_, t, value| t.set_rate(value).map(|_| None));
        b.property::<bool, _>("Shuffle")
            .get(|_, t| t.shuffle())
            .set(|_, t, value| t.set_shuffle(value).map(|_| None));
        b.property::<arg::PropMap, _>("Metadata")
            .get(|_, t| t.metadata());
        b.property::<f64, _>("Volume")
            .get(|_, t| t.volume())
            .set(|_, t, value| t.set_volume(value).map(|_| None));
        b.property::<i64, _>("Position").get(|_, t| t.position());
        b.property::<f64, _>("MinimumRate")
            .get(|_, t| t.minimum_rate());
        b.property::<f64, _>("MaximumRate")
            .get(|_, t| t.maximum_rate());
        b.property::<bool, _>("CanGoNext")
            .get(|_, t| t.can_go_next());
        b.property::<bool, _>("CanGoPrevious")
            .get(|_, t| t.can_go_previous());
        b.property::<bool, _>("CanPlay").get(|_, t| t.can_play());
        b.property::<bool, _>("CanPause").get(|_, t| t.can_pause());
        b.property::<bool, _>("CanSeek").get(|_, t| t.can_seek());
        b.property::<bool, _>("CanControl")
            .get(|_, t| t.can_control());
    })
}

pub trait OrgMprisMediaPlayer2ExtensionSetRatings {
    fn set_rating(
        &mut self,
        track_id: dbus::Path<'static>,
        rating: f64,
    ) -> Result<(), dbus::MethodErr>;
    fn has_ratings_extension(&self) -> Result<bool, dbus::MethodErr>;
}

pub fn register_org_mpris_media_player2_extension_set_ratings<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgMprisMediaPlayer2ExtensionSetRatings + Send + 'static,
{
    cr.register("org.mpris.MediaPlayer2.ExtensionSetRatings", |b| {
        b.method(
            "SetRating",
            ("TrackId", "Rating"),
            (),
            |_, t: &mut T, (track_id, rating)| t.set_rating(track_id, rating),
        );
        b.property::<bool, _>("HasRatingsExtension")
            .get(|_, t| t.has_ratings_extension());
    })
}
